<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Function Graphs</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Poppins', sans-serif;
            font-size: 16px;
            height: 100vh;
            overflow: hidden;
        }
        .canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #fff;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .controls-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 10px;
            padding-top: 15px;
            margin-top: 10px;
            border-top: 1px solid #ccc;
        }
        .controls-row {
            display: flex;
            gap: 20px;
        }
        .control-block {
            flex: 1;
        }
        .control-block h3 {
            margin: 0 0 5px 0;
            font-size: 18px;
            font-weight: 600;
        }
        input[type="text"] {
            width: 50px;
            font-size: 16px;
            font-family: 'Poppins', sans-serif;
            padding: 3px 6px;
        }
        button {
            font-size: 16px;
            padding: 3px 8px;
            font-family: 'Poppins', sans-serif;
            cursor: pointer;
        }
        .formula {
            font-size: 16px;
            margin: 5px 0;
            font-weight: 600;
        }
        .coords-display {
            position: absolute;
            bottom: 10px;
            right: 10px;
            font-size: 15px;
            padding: 10px 14px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ccc;
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
            pointer-events: none;
            z-index: 10;
        }
        label {
            font-size: 16px;
            margin-right: 5px;
        }
        .derivatives-info {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 12px;
            font-size: 16px;
            background: rgba(245, 245, 245, 0.95);
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            min-width: 300px;
            max-width: 400px;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
        }
        .derivatives-info.hidden {
            display: none;
        }
        .derivatives-content {
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .derivative-item {
            font-family: 'Poppins', sans-serif;
            font-size: 18px;
        }
        .derivative-item div {
            font-family: 'Courier New', monospace;
            line-height: 1.4;
        }
        .legend {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 12px;
            font-size: 16px;
            background: rgba(245, 245, 245, 0.95);
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            max-width: 400px;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
        }
        .legend-main {
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: flex-start;
        }
        .legend label {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .legend span {
            font-weight: 600;
        }
        .controls-container.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="derivatives-info" id="derivativesInfo">
        <button id="toggleDerivatives" style="width: 100%;">Derivatives ▼</button>
        <div class="derivatives-content" id="derivativesContent">
            <div class="derivative-item">
                <strong>dg/dx:</strong> <span id="dgdxValue">—</span>
                <div id="dgdxDetails" style="font-size: 14px; color: #666; margin-top: 4px;"></div>
            </div>
            <div class="derivative-item" style="margin-top: 12px;">
                <strong>df/dg:</strong> <span id="dfdgValue">—</span>
                <div id="dfdgDetails" style="font-size: 14px; color: #666; margin-top: 4px;"></div>
            </div>
            <div class="derivative-item" style="border-top: 1px solid #ccc; padding-top: 8px; margin-top: 12px;">
                <strong>d(f∘g)/dx:</strong> <span id="dcompValue">—</span>
                <div id="dcompDetails" style="font-size: 14px; color: #666; margin-top: 4px;"></div>
            </div>
        </div>
    </div>

    <div class="legend">
        <div class="legend-main">
            <label>
                <input type="checkbox" id="showFunc1" checked>
                <span style="color: #0066cc;">■</span>
                <span id="legendFormula1" style="color: #0066cc; font-weight: bold;"></span>
            </label>
            <label>
                <input type="checkbox" id="showFunc2" checked>
                <span style="color: #cc0000;">■</span>
                <span id="legendFormula2" style="color: #cc0000; font-weight: bold;"></span>
            </label>
            <label>
                <input type="checkbox" id="showComposition" checked>
                <span style="color: #00aa00;">■</span>
                <span id="legendFormula3" style="color: #00aa00; font-weight: bold;">f(g(x))</span>
            </label>
            <label>
                <input type="checkbox" id="showIdentity" checked>
                <span style="color: #888888;">■</span>
                <span style="color: #888888; font-weight: bold;">y = x</span>
            </label>
            <label>
                <input type="checkbox" id="showVerticalLine" checked>
                <span style="color: #cc0000;">│</span>
                <span style="font-weight: bold;">Vertical to g(x)</span>
            </label>
            <label>
                <input type="checkbox" id="showHorizontalToIdentity" checked>
                <span style="color: #888888;">─</span>
                <span style="font-weight: bold;">Horizontal to y=x</span>
            </label>
            <label>
                <input type="checkbox" id="showVerticalToF" checked>
                <span style="color: #0066cc;">│</span>
                <span style="font-weight: bold;">Vertical to f(x)</span>
            </label>
            <label>
                <input type="checkbox" id="showHorizontalToComposition" checked>
                <span style="color: #00aa00;">─</span>
                <span style="font-weight: bold;">Horizontal to f(g(x))</span>
            </label>
            <div style="display: flex; gap: 5px; align-items: center;">
                <label>x = </label>
                <button id="btnXMinus">-</button>
                <input type="text" id="intersectionX" value="" placeholder="?" style="width: 60px;">
                <button id="btnXPlus">+</button>
            </div>
            <div style="display: flex; gap: 5px; align-items: center;">
                <label>dx = </label>
                <button id="btnDxMinus">-</button>
                <input type="text" id="dxInput" value="0.5" style="width: 60px;">
                <button id="btnDxPlus">+</button>
            </div>
            <label>
                <input type="checkbox" id="showDxLines" checked>
                <span style="font-weight: bold;">Show lines for x+dx</span>
            </label>
            <label>
                <input type="checkbox" id="showCoordinates" checked>
                <span style="font-weight: bold;">Show point coordinates</span>
            </label>
            <div style="display: flex; gap: 5px; align-items: center; flex-wrap: wrap;">
                <button id="zoomOut" title="Zoom out">−</button>
                <button id="zoomIn" title="Zoom in">+</button>
                <button id="resetView">Reset view</button>
            </div>
            <div style="display: flex; gap: 5px; align-items: center; flex-wrap: wrap;">
                <button id="moveUp" title="Move up">▲</button>
                <button id="moveDown" title="Move down">▼</button>
                <button id="moveLeft" title="Move left">◀</button>
                <button id="moveRight" title="Move right">▶</button>
            </div>
            <div style="border-top: 1px solid #ccc; width: 100%; margin-top: 12px; padding-top: 12px;">
                <button id="toggleControls" style="width: 100%;">Settings ▼</button>
            </div>
        </div>

        <div class="controls-container hidden">
            <div class="controls-row">
                <div class="control-block">
                    <h3 style="color: #0066cc;">f(x)</h3>
                    <div>
                        <label><input type="radio" name="funcType1" value="polynomial"> Polynomial</label>
                        <label><input type="radio" name="funcType1" value="power" checked> Power</label>
                        <label><input type="radio" name="funcType1" value="sin"> Sine</label>
                        <label><input type="radio" name="funcType1" value="cos"> Cosine</label>
                    </div>
                    <div style="margin-top: 10px;">
                        <div style="margin-bottom: 5px;">
                            <label style="display: inline-block; width: 20px;">a:</label>
                            <button id="btnA1Minus">-</button>
                            <input type="text" id="coeffA1" value="1">
                            <button id="btnA1Plus">+</button>
                        </div>
                        <div style="margin-bottom: 5px;">
                            <label style="display: inline-block; width: 20px;">b:</label>
                            <button id="btnB1Minus">-</button>
                            <input type="text" id="coeffB1" value="0">
                            <button id="btnB1Plus">+</button>
                        </div>
                        <div style="margin-bottom: 5px;">
                            <label style="display: inline-block; width: 20px;">c:</label>
                            <button id="btnC1Minus">-</button>
                            <input type="text" id="coeffC1" value="0">
                            <button id="btnC1Plus">+</button>
                        </div>
                    </div>
                    <div class="formula" id="formula1" style="color: #0066cc;"></div>
                </div>

                <div class="control-block">
                    <h3 style="color: #cc0000;">g(x)</h3>
                    <div>
                        <label><input type="radio" name="funcType2" value="polynomial" checked> Polynomial</label>
                        <label><input type="radio" name="funcType2" value="power"> Power</label>
                        <label><input type="radio" name="funcType2" value="sin"> Sine</label>
                        <label><input type="radio" name="funcType2" value="cos"> Cosine</label>
                    </div>
                    <div style="margin-top: 10px;">
                        <div style="margin-bottom: 5px;">
                            <label style="display: inline-block; width: 20px;">a:</label>
                            <button id="btnA2Minus">-</button>
                            <input type="text" id="coeffA2" value="1">
                            <button id="btnA2Plus">+</button>
                        </div>
                        <div style="margin-bottom: 5px;">
                            <label style="display: inline-block; width: 20px;">b:</label>
                            <button id="btnB2Minus">-</button>
                            <input type="text" id="coeffB2" value="0">
                            <button id="btnB2Plus">+</button>
                        </div>
                        <div style="margin-bottom: 5px;">
                            <label style="display: inline-block; width: 20px;">c:</label>
                            <button id="btnC2Minus">-</button>
                            <input type="text" id="coeffC2" value="0">
                            <button id="btnC2Plus">+</button>
                        </div>
                    </div>
                    <div class="formula" id="formula2" style="color: #cc0000;"></div>
                </div>
            </div>
            <button id="resetToDefaults" style="width: 100%;">Reset to defaults</button>
        </div>
    </div>

    <div class="canvas-container">
        <canvas id="mainCanvas"></canvas>
        <!-- <div class="coords-display" id="coordsDisplay">Hover over the graph</div> -->
    </div>

    <script>
        class FunctionData {
            constructor(config) {
                this.coeffAInput = document.getElementById(config.coeffAId);
                this.coeffBInput = document.getElementById(config.coeffBId);
                this.coeffCInput = document.getElementById(config.coeffCId);
                this.formulaDisplay = document.getElementById(config.formulaId);
                this.legendFormulaDisplay = config.legendFormulaId ? document.getElementById(config.legendFormulaId) : null;
                this.funcTypeRadios = document.getElementsByName(config.funcTypeName);
                
                this.storageKey = config.storageKey;
                this.label = config.label;
                this.color = config.color;
                
                this.a = 1;
                this.b = 0;
                this.c = 0;
                this.funcType = 'polynomial';
                
                this.loadFromStorage();
                this.setupEventListeners(config);
                this.updateFormula();
            }
            
            loadFromStorage() {
                if (!this.storageKey) return;
                
                const saved = localStorage.getItem(this.storageKey);
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        this.a = data.a ?? 1;
                        this.b = data.b ?? 0;
                        this.c = data.c ?? 0;
                        this.funcType = data.funcType ?? 'polynomial';
                        
                        this.coeffAInput.value = this.a;
                        this.coeffBInput.value = this.b;
                        this.coeffCInput.value = this.c;
                        
                        this.funcTypeRadios.forEach(radio => {
                            radio.checked = radio.value === this.funcType;
                        });
                    } catch (e) {
                        console.error('Error loading from localStorage:', e);
                    }
                }
            }
            
            saveToStorage() {
                if (!this.storageKey) return;
                
                const data = {
                    a: this.a,
                    b: this.b,
                    c: this.c,
                    funcType: this.funcType
                };
                
                try {
                    localStorage.setItem(this.storageKey, JSON.stringify(data));
                } catch (e) {
                    console.error('Error saving to localStorage:', e);
                }
            }
            
            calculateY(x) {
                if (this.funcType === 'polynomial') {
                    return this.a * x * x + this.b * x + this.c;
                } else if (this.funcType === 'power') {
                    return this.a * Math.pow(x, this.b) + this.c;
                } else if (this.funcType === 'sin') {
                    return this.a * Math.sin(this.b * x) + this.c;
                } else if (this.funcType === 'cos') {
                    return this.a * Math.cos(this.b * x) + this.c;
                }
            }
            
            updateFormula() {
                let formula = this.label + ' = ';
                
                if (this.funcType === 'polynomial') {
                    let terms = [];
                    
                    if (this.a !== 0) {
                        if (this.a === 1) terms.push('x<sup>2</sup>');
                        else if (this.a === -1) terms.push('-x<sup>2</sup>');
                        else terms.push(`${this.a}x<sup>2</sup>`);
                    }
                    
                    if (this.b !== 0) {
                        if (this.b === 1) terms.push(terms.length > 0 ? '+ x' : 'x');
                        else if (this.b === -1) terms.push('- x');
                        else if (this.b > 0 && terms.length > 0) terms.push(`+ ${this.b}x`);
                        else terms.push(`${this.b}x`);
                    }
                    
                    if (this.c !== 0) {
                        if (this.c > 0 && terms.length > 0) terms.push(`+ ${this.c}`);
                        else terms.push(`${this.c}`);
                    }
                    
                    if (terms.length === 0) {
                        formula += '0';
                    } else {
                        formula += terms.join(' ');
                    }
                } else if (this.funcType === 'power') {
                    const aStr = this.a === 1 ? '' : this.a === -1 ? '-' : `${this.a}`;
                    const bStr = this.b === 1 ? '' : `<sup>${this.b}</sup>`;
                    const cStr = this.c === 0 ? '' : this.c > 0 ? ` + ${this.c}` : ` - ${Math.abs(this.c)}`;
                    formula += `${aStr}x${bStr}${cStr}`;
                } else if (this.funcType === 'sin') {
                    const aStr = this.a === 1 ? '' : this.a === -1 ? '-' : `${this.a}`;
                    const bStr = this.b === 0 ? '0' : this.b === 1 ? 'x' : this.b === -1 ? '-x' : `${this.b}x`;
                    const cStr = this.c === 0 ? '' : this.c > 0 ? ` + ${this.c}` : ` - ${Math.abs(this.c)}`;
                    formula += `${aStr}sin(${bStr})${cStr}`;
                } else if (this.funcType === 'cos') {
                    const aStr = this.a === 1 ? '' : this.a === -1 ? '-' : `${this.a}`;
                    const bStr = this.b === 0 ? '0' : this.b === 1 ? 'x' : this.b === -1 ? '-x' : `${this.b}x`;
                    const cStr = this.c === 0 ? '' : this.c > 0 ? ` + ${this.c}` : ` - ${Math.abs(this.c)}`;
                    formula += `${aStr}cos(${bStr})${cStr}`;
                }
                
                this.formulaDisplay.innerHTML = formula;
                
                // Обновляем формулу в легенде
                if (this.legendFormulaDisplay) {
                    this.legendFormulaDisplay.innerHTML = formula;
                }
            }
            
            updateCoefficients() {
                const newA = parseFloat(this.coeffAInput.value);
                const newB = parseFloat(this.coeffBInput.value);
                const newC = parseFloat(this.coeffCInput.value);
                
                if (!isNaN(newA)) this.a = newA;
                if (!isNaN(newB)) this.b = newB;
                if (!isNaN(newC)) this.c = newC;
                
                this.updateFormula();
                this.saveToStorage();
                if (this.onUpdate) this.onUpdate();
            }
            
            updateInputValue(input, coeff, value) {
                const rounded = Math.round(value * 10) / 10;
                input.value = rounded;
                if (coeff === 'a') this.a = rounded;
                else if (coeff === 'b') this.b = rounded;
                else if (coeff === 'c') this.c = rounded;
                this.updateFormula();
                this.saveToStorage();
                if (this.onUpdate) this.onUpdate();
            }
            
            setupEventListeners(config) {
                this.coeffAInput.addEventListener('input', () => this.updateCoefficients());
                this.coeffBInput.addEventListener('input', () => this.updateCoefficients());
                this.coeffCInput.addEventListener('input', () => this.updateCoefficients());
                
                document.getElementById(config.btnAMinusId).addEventListener('click', () => 
                    this.updateInputValue(this.coeffAInput, 'a', this.a - 0.1));
                document.getElementById(config.btnAPlusId).addEventListener('click', () => 
                    this.updateInputValue(this.coeffAInput, 'a', this.a + 0.1));
                document.getElementById(config.btnBMinusId).addEventListener('click', () => 
                    this.updateInputValue(this.coeffBInput, 'b', this.b - 0.1));
                document.getElementById(config.btnBPlusId).addEventListener('click', () => 
                    this.updateInputValue(this.coeffBInput, 'b', this.b + 0.1));
                document.getElementById(config.btnCMinusId).addEventListener('click', () => 
                    this.updateInputValue(this.coeffCInput, 'c', this.c - 0.1));
                document.getElementById(config.btnCPlusId).addEventListener('click', () => 
                    this.updateInputValue(this.coeffCInput, 'c', this.c + 0.1));
                
                this.funcTypeRadios.forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        this.funcType = e.target.value;
                        this.updateFormula();
                        this.saveToStorage();
                        if (this.onUpdate) this.onUpdate();
                    });
                });
            }
        }
        
        class CombinedGraph {
            constructor(canvasId, func1, func2) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.coordsDisplay = document.getElementById('coordsDisplay');
                
                this.func1 = func1;
                this.func2 = func2;
                
                this.showFunc1Checkbox = document.getElementById('showFunc1');
                this.showFunc2Checkbox = document.getElementById('showFunc2');
                this.showCompositionCheckbox = document.getElementById('showComposition');
                this.showIdentityCheckbox = document.getElementById('showIdentity');
                
                this.dpr = window.devicePixelRatio || 1;
                
                this.scale = 40;
                this.offsetX = 0;
                this.offsetY = 0;
                
                this.isDragging = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                
                // Initialize canvas size
                this.updateCanvasSize();
                
                this.loadVisibilityState();
                this.loadViewState();
                this.setupEventListeners();
                this.draw();
            }
            
            updateCanvasSize() {
                // Canvas занимает весь экран
                this.displayWidth = window.innerWidth;
                this.displayHeight = window.innerHeight;
                
                // Account for device pixel ratio
                this.canvas.width = this.displayWidth * this.dpr;
                this.canvas.height = this.displayHeight * this.dpr;
                
                // Reset the scale for the new size
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.scale(this.dpr, this.dpr);
                
                this.width = this.displayWidth;
                this.height = this.displayHeight;
                this.centerX = this.width / 2;
                this.centerY = this.height / 2;
            }
            
            loadVisibilityState() {
                try {
                    const saved = localStorage.getItem('graph-visibility');
                    if (saved) {
                        const state = JSON.parse(saved);
                        this.showFunc1Checkbox.checked = state.showFunc1 !== false;
                        this.showFunc2Checkbox.checked = state.showFunc2 !== false;
                        this.showCompositionCheckbox.checked = state.showComposition !== false;
                        this.showIdentityCheckbox.checked = state.showIdentity !== false;
                        
                        const showVerticalLineCheckbox = document.getElementById('showVerticalLine');
                        if (state.showVerticalLine !== undefined) {
                            showVerticalLineCheckbox.checked = state.showVerticalLine;
                        }
                        
                        const showHorizontalToIdentityCheckbox = document.getElementById('showHorizontalToIdentity');
                        if (state.showHorizontalToIdentity !== undefined) {
                            showHorizontalToIdentityCheckbox.checked = state.showHorizontalToIdentity;
                        }
                        
                        const showVerticalToFCheckbox = document.getElementById('showVerticalToF');
                        if (state.showVerticalToF !== undefined) {
                            showVerticalToFCheckbox.checked = state.showVerticalToF;
                        }
                        
                        const showHorizontalToCompositionCheckbox = document.getElementById('showHorizontalToComposition');
                        if (state.showHorizontalToComposition !== undefined) {
                            showHorizontalToCompositionCheckbox.checked = state.showHorizontalToComposition;
                        }
                        
                        const showDxLinesCheckbox = document.getElementById('showDxLines');
                        if (state.showDxLines !== undefined) {
                            showDxLinesCheckbox.checked = state.showDxLines;
                        }
                        
                        const showCoordinatesCheckbox = document.getElementById('showCoordinates');
                        if (state.showCoordinates !== undefined) {
                            showCoordinatesCheckbox.checked = state.showCoordinates;
                        }
                    }
                    
                    // Загружаем значение x для пересечения
                    const savedX = localStorage.getItem('intersection-x');
                    if (savedX !== null) {
                        document.getElementById('intersectionX').value = savedX;
                    }
                    
                    // Загружаем значение dx
                    const savedDx = localStorage.getItem('dx-value');
                    if (savedDx !== null) {
                        document.getElementById('dxInput').value = savedDx;
                    }
                } catch (e) {
                    console.error('Error loading visibility state:', e);
                }
            }
            
            saveVisibilityState() {
                try {
                    const state = {
                        showFunc1: this.showFunc1Checkbox.checked,
                        showFunc2: this.showFunc2Checkbox.checked,
                        showComposition: this.showCompositionCheckbox.checked,
                        showIdentity: this.showIdentityCheckbox.checked,
                        showVerticalLine: document.getElementById('showVerticalLine').checked,
                        showHorizontalToIdentity: document.getElementById('showHorizontalToIdentity').checked,
                        showVerticalToF: document.getElementById('showVerticalToF').checked,
                        showHorizontalToComposition: document.getElementById('showHorizontalToComposition').checked,
                        showDxLines: document.getElementById('showDxLines').checked,
                        showCoordinates: document.getElementById('showCoordinates').checked
                    };
                    localStorage.setItem('graph-visibility', JSON.stringify(state));
                } catch (e) {
                    console.error('Error saving visibility state:', e);
                }
            }
            
            saveIntersectionX() {
                try {
                    const value = document.getElementById('intersectionX').value;
                    localStorage.setItem('intersection-x', value);
                } catch (e) {
                    console.error('Error saving intersection x:', e);
                }
            }
            
            saveDx() {
                try {
                    const value = document.getElementById('dxInput').value;
                    localStorage.setItem('dx-value', value);
                } catch (e) {
                    console.error('Error saving dx:', e);
                }
            }
            
            loadViewState() {
                try {
                    const saved = localStorage.getItem('graph-view');
                    if (saved) {
                        const state = JSON.parse(saved);
                        this.scale = state.scale || 40;
                        this.offsetX = state.offsetX || 0;
                        this.offsetY = state.offsetY || 0;
                    }
                } catch (e) {
                    console.error('Error loading view state:', e);
                }
            }
            
            saveViewState() {
                try {
                    const state = {
                        scale: this.scale,
                        offsetX: this.offsetX,
                        offsetY: this.offsetY
                    };
                    localStorage.setItem('graph-view', JSON.stringify(state));
                } catch (e) {
                    console.error('Error saving view state:', e);
                }
            }
            
            toCanvasX(x) {
                return this.centerX + this.offsetX + x * this.scale;
            }
            
            toCanvasY(y) {
                return this.centerY + this.offsetY - y * this.scale;
            }
            
            toMathX(canvasX) {
                return (canvasX - this.centerX - this.offsetX) / this.scale;
            }
            
            toMathY(canvasY) {
                return (this.centerY + this.offsetY - canvasY) / this.scale;
            }
            
            drawGrid() {
                this.ctx.strokeStyle = '#e0e0e0';
                this.ctx.lineWidth = 1;
                
                // Вычисляем диапазон видимых координат
                const minX = Math.floor(this.toMathX(0));
                const maxX = Math.ceil(this.toMathX(this.width));
                const minY = Math.floor(this.toMathY(this.height));
                const maxY = Math.ceil(this.toMathY(0));
                
                // Вертикальные линии
                for (let x = minX; x <= maxX; x++) {
                    const canvasX = this.toCanvasX(x);
                    if (canvasX >= 0 && canvasX <= this.width) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(canvasX, 0);
                        this.ctx.lineTo(canvasX, this.height);
                        this.ctx.stroke();
                    }
                }
                
                // Горизонтальные линии
                for (let y = minY; y <= maxY; y++) {
                    const canvasY = this.toCanvasY(y);
                    if (canvasY >= 0 && canvasY <= this.height) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, canvasY);
                        this.ctx.lineTo(this.width, canvasY);
                        this.ctx.stroke();
                    }
                }
            }
            
            drawAxes() {
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 2;
                
                const axisY = this.toCanvasY(0);
                const axisX = this.toCanvasX(0);
                
                // Ось X
                if (axisY >= 0 && axisY <= this.height) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, axisY);
                    this.ctx.lineTo(this.width, axisY);
                    this.ctx.stroke();
                }
                
                // Ось Y
                if (axisX >= 0 && axisX <= this.width) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(axisX, 0);
                    this.ctx.lineTo(axisX, this.height);
                    this.ctx.stroke();
                }
                
                this.ctx.fillStyle = '#333';
                this.ctx.font = '16px Poppins, sans-serif';
                
                // Вычисляем диапазон видимых координат
                const minX = Math.floor(this.toMathX(0));
                const maxX = Math.ceil(this.toMathX(this.width));
                const minY = Math.floor(this.toMathY(this.height));
                const maxY = Math.ceil(this.toMathY(0));
                
                // Подписи на оси X (фиксированный шаг = 1)
                for (let x = minX; x <= maxX; x++) {
                    if (x === 0) continue;
                    const canvasX = this.toCanvasX(x);
                    if (canvasX >= 0 && canvasX <= this.width && axisY >= 0 && axisY <= this.height) {
                        this.ctx.fillText(x, canvasX - 5, axisY + 15);
                        this.ctx.beginPath();
                        this.ctx.moveTo(canvasX, axisY - 5);
                        this.ctx.lineTo(canvasX, axisY + 5);
                        this.ctx.stroke();
                    }
                }
                
                // Подписи на оси Y (фиксированный шаг = 1)
                for (let y = minY; y <= maxY; y++) {
                    if (y === 0) continue;
                    const canvasY = this.toCanvasY(y);
                    if (canvasY >= 0 && canvasY <= this.height && axisX >= 0 && axisX <= this.width) {
                        this.ctx.fillText(y, axisX + 10, canvasY + 5);
                        this.ctx.beginPath();
                        this.ctx.moveTo(axisX - 5, canvasY);
                        this.ctx.lineTo(axisX + 5, canvasY);
                        this.ctx.stroke();
                    }
                }
                
                // Подписи осей
                if (axisY >= 0 && axisY <= this.height) {
                    this.ctx.fillText('x', this.width - 20, axisY - 10);
                }
                if (axisX >= 0 && axisX <= this.width) {
                    this.ctx.fillText('y', axisX - 20, 20);
                }
            }
            
            drawFunction(func) {
                this.ctx.strokeStyle = func.color;
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                
                let firstPoint = true;
                for (let canvasX = 0; canvasX <= this.width; canvasX++) {
                    const x = this.toMathX(canvasX);
                    const y = func.calculateY(x);
                    const canvasY = this.toCanvasY(y);
                    
                    if (!isNaN(y) && isFinite(y) && canvasY >= -this.height && canvasY <= this.height * 2) {
                        if (firstPoint) {
                            this.ctx.moveTo(canvasX, canvasY);
                            firstPoint = false;
                        } else {
                            this.ctx.lineTo(canvasX, canvasY);
                        }
                    } else {
                        firstPoint = true;
                    }
                }
                
                this.ctx.stroke();
            }
            
            drawComposition() {
                this.ctx.strokeStyle = '#00aa00';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                
                let firstPoint = true;
                for (let canvasX = 0; canvasX <= this.width; canvasX++) {
                    const x = this.toMathX(canvasX);
                    const gx = this.func2.calculateY(x);
                    const y = this.func1.calculateY(gx);
                    const canvasY = this.toCanvasY(y);
                    
                    if (!isNaN(y) && isFinite(y) && canvasY >= -this.height && canvasY <= this.height * 2) {
                        if (firstPoint) {
                            this.ctx.moveTo(canvasX, canvasY);
                            firstPoint = false;
                        } else {
                            this.ctx.lineTo(canvasX, canvasY);
                        }
                    } else {
                        firstPoint = true;
                    }
                }
                
                this.ctx.stroke();
            }
            
            drawIdentityLine() {
                this.ctx.strokeStyle = '#888888';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([8, 4]);
                this.ctx.beginPath();
                
                // Определяем видимый диапазон
                const minX = this.toMathX(0);
                const maxX = this.toMathX(this.width);
                
                const startCanvasX = this.toCanvasX(minX);
                const startCanvasY = this.toCanvasY(minX);
                const endCanvasX = this.toCanvasX(maxX);
                const endCanvasY = this.toCanvasY(maxX);
                
                this.ctx.moveTo(startCanvasX, startCanvasY);
                this.ctx.lineTo(endCanvasX, endCanvasY);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }
            
            calculateComposition(x) {
                const gx = this.func2.calculateY(x);
                return this.func1.calculateY(gx);
            }
            
            drawIntersection() {
                const intersectionXInput = document.getElementById('intersectionX');
                const xValue = parseFloat(intersectionXInput.value);
                
                if (isNaN(xValue) || !isFinite(xValue)) {
                    return; // Не рисуем, если значение невалидно
                }
                
                // Вычисляем y = g(x)
                const yValue = this.func2.calculateY(xValue);
                
                // Вычисляем координаты для x+dx
                const dxInput = document.getElementById('dxInput');
                const dxValue = parseFloat(dxInput.value);
                const showDxLinesCheckbox = document.getElementById('showDxLines');
                let xPlusDxCoord = null, yValueDxCoord = null, yValueDxOnIdentity = null, fOfGDxCoord = null;
                
                if (showDxLinesCheckbox && showDxLinesCheckbox.checked && !isNaN(dxValue) && isFinite(dxValue) && dxValue > 0) {
                    const xPlusDx = xValue + dxValue;
                    const yValueDx = this.func2.calculateY(xPlusDx);
                    if (!isNaN(yValueDx) && isFinite(yValueDx)) {
                        xPlusDxCoord = xPlusDx;
                        yValueDxCoord = yValueDx;
                        yValueDxOnIdentity = yValueDx; // для точки на y=x
                        const fOfGDx = this.func1.calculateY(yValueDx);
                        if (!isNaN(fOfGDx) && isFinite(fOfGDx)) {
                            fOfGDxCoord = fOfGDx;
                        }
                    }
                }
                
                if (isNaN(yValue) || !isFinite(yValue)) {
                    return; // Не рисуем, если результат невалиден
                }
                
                const canvasX = this.toCanvasX(xValue);
                const canvasY = this.toCanvasY(yValue);
                
                // Рисуем вертикальную линию только если галочка включена
                const showVerticalLineCheckbox = document.getElementById('showVerticalLine');
                if (showVerticalLineCheckbox && showVerticalLineCheckbox.checked) {
                    const axisY = this.toCanvasY(0); // Позиция оси X на canvas
                    this.ctx.strokeStyle = '#cc0000';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(canvasX, axisY);
                    this.ctx.lineTo(canvasX, canvasY);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
                
                // Рисуем точку пересечения (только если галочка включена)
                if (showVerticalLineCheckbox && showVerticalLineCheckbox.checked && canvasY >= 0 && canvasY <= this.height) {
                    this.ctx.fillStyle = '#cc0000';
                    this.ctx.beginPath();
                    this.ctx.arc(canvasX, canvasY, 4, 0, 2 * Math.PI);
                    this.ctx.fill();
                    
                    // Подпись координат точки
                    const showCoordinatesCheckbox = document.getElementById('showCoordinates');
                    if (showCoordinatesCheckbox && showCoordinatesCheckbox.checked) {
                        this.ctx.font = '600 14px Poppins, sans-serif';
                        const label = `(${xValue.toFixed(2)}, ${yValue.toFixed(2)})`;
                        const labelX = canvasX + 10;
                        const labelY = canvasY - 10;
                        const textMetrics = this.ctx.measureText(label);
                        
                        // Добавляем строку с координатами x+dx, если они есть
                        let deltaLabel = '';
                        let deltaTextMetrics = null;
                        if (xPlusDxCoord !== null && yValueDxCoord !== null) {
                            deltaLabel = `(${xPlusDxCoord.toFixed(2)}, ${yValueDxCoord.toFixed(2)})`;
                            deltaTextMetrics = this.ctx.measureText(deltaLabel);
                        }
                        
                        const padding = 8;
                        const borderRadius = 6;
                        const lineHeight = 18;
                        const maxWidth = Math.max(textMetrics.width, deltaTextMetrics ? deltaTextMetrics.width : 0);
                        
                        // Рисуем полупрозрачную подложку с тенью и закругленными углами
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
                        this.ctx.shadowOffsetX = 0;
                        this.ctx.shadowOffsetY = 2;
                        
                        const boxX = labelX - padding;
                        const boxY = labelY - 14;
                        const boxW = maxWidth + padding * 2;
                        const boxH = deltaLabel ? 40 : 20;
                        
                        this.ctx.beginPath();
                        this.ctx.roundRect(boxX, boxY, boxW, boxH, borderRadius);
                        this.ctx.fillStyle = 'rgba(245, 245, 245, 0.95)';
                        this.ctx.fill();
                        this.ctx.strokeStyle = '#ccc';
                        this.ctx.lineWidth = 1;
                        this.ctx.stroke();
                        
                        // Сбрасываем тень
                        this.ctx.shadowBlur = 0;
                        this.ctx.shadowOffsetY = 0;
                        
                        // Рисуем текст
                        this.ctx.fillStyle = '#000';
                        this.ctx.fillText(label, labelX, labelY);
                        
                        // Рисуем приращения, если есть
                        if (deltaLabel) {
                            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                            this.ctx.font = '400 12px Poppins, sans-serif';
                            this.ctx.fillText(deltaLabel, labelX, labelY + lineHeight);
                        }
                    }
                }
                
                // Проверяем, нужно ли рисовать остальные линии
                if (canvasY >= 0 && canvasY <= this.height) {
                    // На прямой y=x точка будет иметь координаты (yValue, yValue)
                    const identityX = yValue;
                    const identityCanvasX = this.toCanvasX(identityX);
                    const identityCanvasY = this.toCanvasY(yValue);
                    
                    // Рисуем горизонтальную линию до прямой y=x только если галочка включена
                    const showHorizontalToIdentityCheckbox = document.getElementById('showHorizontalToIdentity');
                    if (showHorizontalToIdentityCheckbox && showHorizontalToIdentityCheckbox.checked) {
                        this.ctx.strokeStyle = '#888888';
                        this.ctx.lineWidth = 2;
                        this.ctx.setLineDash([5, 5]);
                        this.ctx.beginPath();
                        this.ctx.moveTo(canvasX, canvasY);
                        this.ctx.lineTo(identityCanvasX, identityCanvasY);
                        this.ctx.stroke();
                        this.ctx.setLineDash([]);
                        
                        // Рисуем точку на y=x
                        this.ctx.fillStyle = '#888888';
                        this.ctx.beginPath();
                        this.ctx.arc(identityCanvasX, identityCanvasY, 4, 0, 2 * Math.PI);
                        this.ctx.fill();
                        
                        // Подпись координат точки на y=x
                        const showCoordinatesCheckbox = document.getElementById('showCoordinates');
                        if (showCoordinatesCheckbox && showCoordinatesCheckbox.checked) {
                            this.ctx.font = '600 14px Poppins, sans-serif';
                            const identityLabel = `(${yValue.toFixed(2)}, ${yValue.toFixed(2)})`;
                            const identityLabelX = identityCanvasX + 10;
                            const identityLabelY = identityCanvasY - 10;
                            const identityTextMetrics = this.ctx.measureText(identityLabel);
                            
                            // Добавляем строку с координатами x+dx на y=x, если они есть
                            let identityDeltaLabel = '';
                            let identityDeltaTextMetrics = null;
                            if (yValueDxOnIdentity !== null) {
                                identityDeltaLabel = `(${yValueDxOnIdentity.toFixed(2)}, ${yValueDxOnIdentity.toFixed(2)})`;
                                identityDeltaTextMetrics = this.ctx.measureText(identityDeltaLabel);
                            }
                            
                            const padding = 8;
                            const borderRadius = 6;
                            const lineHeight = 18;
                            const identityMaxWidth = Math.max(identityTextMetrics.width, identityDeltaTextMetrics ? identityDeltaTextMetrics.width : 0);
                            
                            // Рисуем полупрозрачную подложку с тенью и закругленными углами
                            this.ctx.shadowBlur = 10;
                            this.ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
                            this.ctx.shadowOffsetX = 0;
                            this.ctx.shadowOffsetY = 2;
                            
                            const identityBoxX = identityLabelX - padding;
                            const identityBoxY = identityLabelY - 14;
                            const identityBoxW = identityMaxWidth + padding * 2;
                            const identityBoxH = identityDeltaLabel ? 40 : 20;
                            
                            this.ctx.beginPath();
                            this.ctx.roundRect(identityBoxX, identityBoxY, identityBoxW, identityBoxH, borderRadius);
                            this.ctx.fillStyle = 'rgba(245, 245, 245, 0.95)';
                            this.ctx.fill();
                            this.ctx.strokeStyle = '#ccc';
                            this.ctx.lineWidth = 1;
                            this.ctx.stroke();
                            
                            // Сбрасываем тень
                            this.ctx.shadowBlur = 0;
                            this.ctx.shadowOffsetY = 0;
                            
                            // Рисуем текст
                            this.ctx.fillStyle = '#000';
                            this.ctx.fillText(identityLabel, identityLabelX, identityLabelY);
                            
                            // Рисуем приращения, если есть
                            if (identityDeltaLabel) {
                                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                                this.ctx.font = '400 12px Poppins, sans-serif';
                                this.ctx.fillText(identityDeltaLabel, identityLabelX, identityLabelY + lineHeight);
                            }
                        }
                    }
                    
                    // Рисуем вертикальную линию до f(x)
                    // Вычисляем f(g(x))
                    const fOfG = this.func1.calculateY(yValue);
                    
                    if (!isNaN(fOfG) && isFinite(fOfG)) {
                        const fOfGCanvasY = this.toCanvasY(fOfG);
                        
                        // Рисуем вертикальную синюю линию только если галочка включена
                        const showVerticalToFCheckbox = document.getElementById('showVerticalToF');
                        if (showVerticalToFCheckbox && showVerticalToFCheckbox.checked) {
                            this.ctx.strokeStyle = '#0066cc';
                            this.ctx.lineWidth = 2;
                            this.ctx.setLineDash([5, 5]);
                            this.ctx.beginPath();
                            this.ctx.moveTo(identityCanvasX, identityCanvasY);
                            this.ctx.lineTo(identityCanvasX, fOfGCanvasY);
                            this.ctx.stroke();
                            this.ctx.setLineDash([]);
                            
                            // Рисуем точку на f(x)
                            this.ctx.fillStyle = '#0066cc';
                            this.ctx.beginPath();
                            this.ctx.arc(identityCanvasX, fOfGCanvasY, 4, 0, 2 * Math.PI);
                            this.ctx.fill();
                            
                            // Подпись координат точки на f(x)
                            const showCoordinatesCheckbox = document.getElementById('showCoordinates');
                            if (showCoordinatesCheckbox && showCoordinatesCheckbox.checked) {
                                this.ctx.font = '600 14px Poppins, sans-serif';
                                const fLabel = `(${yValue.toFixed(2)}, ${fOfG.toFixed(2)})`;
                                const fLabelX = identityCanvasX + 10;
                                const fLabelY = fOfGCanvasY - 10;
                                const fTextMetrics = this.ctx.measureText(fLabel);
                                
                                // Добавляем строку с координатами x+dx на f(x), если они есть
                                let fDeltaLabel = '';
                                let fDeltaTextMetrics = null;
                                if (yValueDxOnIdentity !== null && fOfGDxCoord !== null) {
                                    fDeltaLabel = `(${yValueDxOnIdentity.toFixed(2)}, ${fOfGDxCoord.toFixed(2)})`;
                                    fDeltaTextMetrics = this.ctx.measureText(fDeltaLabel);
                                }
                                
                                const padding = 8;
                                const borderRadius = 6;
                                const lineHeight = 18;
                                const fMaxWidth = Math.max(fTextMetrics.width, fDeltaTextMetrics ? fDeltaTextMetrics.width : 0);
                                
                                // Рисуем полупрозрачную подложку с тенью и закругленными углами
                                this.ctx.shadowBlur = 10;
                                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
                                this.ctx.shadowOffsetX = 0;
                                this.ctx.shadowOffsetY = 2;
                                
                                const fBoxX = fLabelX - padding;
                                const fBoxY = fLabelY - 14;
                                const fBoxW = fMaxWidth + padding * 2;
                                const fBoxH = fDeltaLabel ? 40 : 20;
                                
                                this.ctx.beginPath();
                                this.ctx.roundRect(fBoxX, fBoxY, fBoxW, fBoxH, borderRadius);
                                this.ctx.fillStyle = 'rgba(245, 245, 245, 0.95)';
                                this.ctx.fill();
                                this.ctx.strokeStyle = '#ccc';
                                this.ctx.lineWidth = 1;
                                this.ctx.stroke();
                                
                                // Сбрасываем тень
                                this.ctx.shadowBlur = 0;
                                this.ctx.shadowOffsetY = 0;
                                
                                // Рисуем текст
                                this.ctx.fillStyle = '#000';
                                this.ctx.fillText(fLabel, fLabelX, fLabelY);
                                
                                // Рисуем приращения, если есть
                                if (fDeltaLabel) {
                                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                                    this.ctx.font = '400 12px Poppins, sans-serif';
                                    this.ctx.fillText(fDeltaLabel, fLabelX, fLabelY + lineHeight);
                                }
                            }
                        }
                        
                        // Рисуем горизонтальную линию до f(g(x)) только если галочка включена
                        const showHorizontalToCompositionCheckbox = document.getElementById('showHorizontalToComposition');
                        if (showHorizontalToCompositionCheckbox && showHorizontalToCompositionCheckbox.checked) {
                            // Точка на f(g(x)) имеет координаты (xValue, f(g(xValue)))
                            const compositionCanvasX = this.toCanvasX(xValue);
                            
                            // Рисуем горизонтальную зеленую линию
                            this.ctx.strokeStyle = '#00aa00';
                            this.ctx.lineWidth = 2;
                            this.ctx.setLineDash([5, 5]);
                            this.ctx.beginPath();
                            this.ctx.moveTo(identityCanvasX, fOfGCanvasY);
                            this.ctx.lineTo(compositionCanvasX, fOfGCanvasY);
                            this.ctx.stroke();
                            this.ctx.setLineDash([]);
                            
                            // Рисуем точку на f(g(x))
                            this.ctx.fillStyle = '#00aa00';
                            this.ctx.beginPath();
                            this.ctx.arc(compositionCanvasX, fOfGCanvasY, 4, 0, 2 * Math.PI);
                            this.ctx.fill();
                            
                            // Подпись координат точки на f(g(x))
                            const showCoordinatesCheckbox = document.getElementById('showCoordinates');
                            if (showCoordinatesCheckbox && showCoordinatesCheckbox.checked) {
                                this.ctx.font = '600 14px Poppins, sans-serif';
                                const compositionLabel = `(${xValue.toFixed(2)}, ${fOfG.toFixed(2)})`;
                                const compositionLabelX = compositionCanvasX + 10;
                                const compositionLabelY = fOfGCanvasY - 10;
                                const compositionTextMetrics = this.ctx.measureText(compositionLabel);
                                
                                // Добавляем строку с координатами x+dx на f(g(x)), если они есть
                                let compositionDeltaLabel = '';
                                let compositionDeltaTextMetrics = null;
                                if (xPlusDxCoord !== null && fOfGDxCoord !== null) {
                                    compositionDeltaLabel = `(${xPlusDxCoord.toFixed(2)}, ${fOfGDxCoord.toFixed(2)})`;
                                    compositionDeltaTextMetrics = this.ctx.measureText(compositionDeltaLabel);
                                }
                                
                                const padding = 8;
                                const borderRadius = 6;
                                const lineHeight = 18;
                                const compositionMaxWidth = Math.max(compositionTextMetrics.width, compositionDeltaTextMetrics ? compositionDeltaTextMetrics.width : 0);
                                
                                // Рисуем полупрозрачную подложку с тенью и закругленными углами
                                this.ctx.shadowBlur = 10;
                                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
                                this.ctx.shadowOffsetX = 0;
                                this.ctx.shadowOffsetY = 2;
                                
                                const compositionBoxX = compositionLabelX - padding;
                                const compositionBoxY = compositionLabelY - 14;
                                const compositionBoxW = compositionMaxWidth + padding * 2;
                                const compositionBoxH = compositionDeltaLabel ? 40 : 20;
                                
                                this.ctx.beginPath();
                                this.ctx.roundRect(compositionBoxX, compositionBoxY, compositionBoxW, compositionBoxH, borderRadius);
                                this.ctx.fillStyle = 'rgba(245, 245, 245, 0.95)';
                                this.ctx.fill();
                                this.ctx.strokeStyle = '#ccc';
                                this.ctx.lineWidth = 1;
                                this.ctx.stroke();
                                
                                // Сбрасываем тень
                                this.ctx.shadowBlur = 0;
                                this.ctx.shadowOffsetY = 0;
                                
                                // Рисуем текст
                                this.ctx.fillStyle = '#000';
                                this.ctx.fillText(compositionLabel, compositionLabelX, compositionLabelY);
                                
                                // Рисуем приращения, если есть
                                if (compositionDeltaLabel) {
                                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                                    this.ctx.font = '400 12px Poppins, sans-serif';
                                    this.ctx.fillText(compositionDeltaLabel, compositionLabelX, compositionLabelY + lineHeight);
                                }
                            }
                        }
                    }
                }
                
                // ====== Рисуем все линии для x + dx ======
                if (showDxLinesCheckbox && showDxLinesCheckbox.checked && !isNaN(dxValue) && isFinite(dxValue) && dxValue > 0) {
                    const xPlusDx = xValue + dxValue;
                    const yValueDx = this.func2.calculateY(xPlusDx);
                    
                    if (!isNaN(yValueDx) && isFinite(yValueDx)) {
                        const canvasXDx = this.toCanvasX(xPlusDx);
                        const canvasYDx = this.toCanvasY(yValueDx);
                        
                        // Вертикальная линия от оси X до g(x+dx)
                        if (showVerticalLineCheckbox && showVerticalLineCheckbox.checked) {
                            const axisY = this.toCanvasY(0);
                            this.ctx.strokeStyle = 'rgba(204, 0, 0, 0.5)'; // Полупрозрачный красный
                            this.ctx.lineWidth = 2;
                            this.ctx.setLineDash([5, 5]);
                            this.ctx.beginPath();
                            this.ctx.moveTo(canvasXDx, axisY);
                            this.ctx.lineTo(canvasXDx, canvasYDx);
                            this.ctx.stroke();
                            this.ctx.setLineDash([]);
                            
                            // Точка на g(x+dx)
                            this.ctx.fillStyle = 'rgba(204, 0, 0, 0.5)';
                            this.ctx.beginPath();
                            this.ctx.arc(canvasXDx, canvasYDx, 4, 0, 2 * Math.PI);
                            this.ctx.fill();
                            
                        }
                        
                        // Остальные линии для x+dx (рисуем всегда)
                        const identityXDx = yValueDx;
                        const identityCanvasXDx = this.toCanvasX(identityXDx);
                        const identityCanvasYDx = this.toCanvasY(yValueDx);
                        
                        // Горизонтальная линия до y=x
                        const showHorizontalToIdentityCheckbox = document.getElementById('showHorizontalToIdentity');
                        if (showHorizontalToIdentityCheckbox && showHorizontalToIdentityCheckbox.checked) {
                            this.ctx.strokeStyle = 'rgba(136, 136, 136, 0.5)'; // Полупрозрачный серый
                            this.ctx.lineWidth = 2;
                            this.ctx.setLineDash([5, 5]);
                            this.ctx.beginPath();
                            this.ctx.moveTo(canvasXDx, canvasYDx);
                            this.ctx.lineTo(identityCanvasXDx, identityCanvasYDx);
                            this.ctx.stroke();
                            this.ctx.setLineDash([]);
                            
                            // Точка на y=x
                            this.ctx.fillStyle = 'rgba(136, 136, 136, 0.5)';
                            this.ctx.beginPath();
                            this.ctx.arc(identityCanvasXDx, identityCanvasYDx, 4, 0, 2 * Math.PI);
                            this.ctx.fill();
                        }
                        
                        // Вертикальная линия до f(x+dx)
                        const fOfGDx = this.func1.calculateY(yValueDx);
                        
                        if (!isNaN(fOfGDx) && isFinite(fOfGDx)) {
                            const fOfGCanvasYDx = this.toCanvasY(fOfGDx);
                            
                            const showVerticalToFCheckbox = document.getElementById('showVerticalToF');
                            if (showVerticalToFCheckbox && showVerticalToFCheckbox.checked) {
                                this.ctx.strokeStyle = 'rgba(0, 102, 204, 0.5)'; // Полупрозрачный синий
                                this.ctx.lineWidth = 2;
                                this.ctx.setLineDash([5, 5]);
                                this.ctx.beginPath();
                                this.ctx.moveTo(identityCanvasXDx, identityCanvasYDx);
                                this.ctx.lineTo(identityCanvasXDx, fOfGCanvasYDx);
                                this.ctx.stroke();
                                this.ctx.setLineDash([]);
                                
                                // Точка на f(x+dx)
                                this.ctx.fillStyle = 'rgba(0, 102, 204, 0.5)';
                                this.ctx.beginPath();
                                this.ctx.arc(identityCanvasXDx, fOfGCanvasYDx, 4, 0, 2 * Math.PI);
                                this.ctx.fill();
                            }
                            
                            // Горизонтальная линия до f(g(x+dx))
                            const showHorizontalToCompositionCheckbox = document.getElementById('showHorizontalToComposition');
                            if (showHorizontalToCompositionCheckbox && showHorizontalToCompositionCheckbox.checked) {
                                this.ctx.strokeStyle = 'rgba(0, 170, 0, 0.5)'; // Полупрозрачный зелёный
                                this.ctx.lineWidth = 2;
                                this.ctx.setLineDash([5, 5]);
                                this.ctx.beginPath();
                                this.ctx.moveTo(identityCanvasXDx, fOfGCanvasYDx);
                                this.ctx.lineTo(canvasXDx, fOfGCanvasYDx);
                                this.ctx.stroke();
                                this.ctx.setLineDash([]);
                                
                                // Точка на f(g(x+dx))
                                this.ctx.fillStyle = 'rgba(0, 170, 0, 0.5)';
                                this.ctx.beginPath();
                                this.ctx.arc(canvasXDx, fOfGCanvasYDx, 4, 0, 2 * Math.PI);
                                this.ctx.fill();
                            }
                        }
                    }
                }
            }
            
            updateDerivatives() {
                const intersectionXInput = document.getElementById('intersectionX');
                const xValue = parseFloat(intersectionXInput.value);
                const dxInput = document.getElementById('dxInput');
                const dxValue = parseFloat(dxInput.value);
                const xdx = xValue + dxValue;
                
                const dgdxValueEl = document.getElementById('dgdxValue');
                const dfdgValueEl = document.getElementById('dfdgValue');
                const dcompValueEl = document.getElementById('dcompValue');
                const dgdxDetailsEl = document.getElementById('dgdxDetails');
                const dfdgDetailsEl = document.getElementById('dfdgDetails');
                const dcompDetailsEl = document.getElementById('dcompDetails');
                
                if (isNaN(xValue) || !isFinite(xValue) || isNaN(dxValue) || !isFinite(dxValue) || dxValue <= 0) {
                    dgdxValueEl.textContent = '—';
                    dfdgValueEl.textContent = '—';
                    dcompValueEl.textContent = '—';
                    dgdxDetailsEl.textContent = '';
                    dfdgDetailsEl.textContent = '';
                    dcompDetailsEl.textContent = '';
                    return;
                }
                
                // Вычисляем dg/dx
                const g_x = this.func2.calculateY(xValue);
                const g_x_plus_dx = this.func2.calculateY(xValue + dxValue);
                
                if (isNaN(g_x) || !isFinite(g_x) || isNaN(g_x_plus_dx) || !isFinite(g_x_plus_dx)) {
                    dgdxValueEl.textContent = '—';
                    dfdgValueEl.textContent = '—';
                    dcompValueEl.textContent = '—';
                    dgdxDetailsEl.textContent = '';
                    dfdgDetailsEl.textContent = '';
                    dcompDetailsEl.textContent = '';
                    return;
                }
                
                const dgdx = (g_x_plus_dx - g_x) / dxValue;
                dgdxValueEl.textContent = dgdx.toFixed(3);
                dgdxDetailsEl.innerHTML = `= (${g_x_plus_dx.toFixed(3)} - ${g_x.toFixed(3)}) / (${xdx.toFixed(2)} - ${xValue.toFixed(2)})<br>` +
                    `= ${(g_x_plus_dx - g_x).toFixed(3)} / ${dxValue.toFixed(2)}`;
                
                // Вычисляем df/dg
                const dg = g_x_plus_dx - g_x;
                const f_g = this.func1.calculateY(g_x);
                const f_g_plus_dg = this.func1.calculateY(g_x_plus_dx);
                
                if (isNaN(f_g) || !isFinite(f_g) || isNaN(f_g_plus_dg) || !isFinite(f_g_plus_dg)) {
                    dfdgValueEl.textContent = '—';
                    dcompValueEl.textContent = '—';
                    dfdgDetailsEl.textContent = '';
                    dcompDetailsEl.textContent = '';
                    return;
                }
                
                const dfdg = dg !== 0 ? (f_g_plus_dg - f_g) / dg : 0;
                dfdgValueEl.textContent = dfdg.toFixed(3);
                dfdgDetailsEl.innerHTML = `= (${f_g_plus_dg.toFixed(3)} - ${f_g.toFixed(3)}) / (${g_x_plus_dx.toFixed(3)} - ${dg.toFixed(3)})<br>` +
                    `= ${(f_g_plus_dg - f_g).toFixed(3)} / ${dg.toFixed(3)}`;
                
                // Вычисляем d(f∘g)/dx = (df/dg) * (dg/dx)
                const dcomp = dfdg * dgdx;
                dcompValueEl.textContent = dcomp.toFixed(3);
                dcompDetailsEl.innerHTML = 
                    `= (df/dg) × (dg/dx)<br>` +
                    `= ((${g_x_plus_dx.toFixed(3)} - ${g_x.toFixed(3)}) / (${xdx.toFixed(2)} - ${xValue.toFixed(2)}))<br>` +
                    `× ч((${f_g_plus_dg.toFixed(3)} - ${f_g.toFixed(3)}) / (${g_x_plus_dx.toFixed(3)} - ${dg.toFixed(3)}))<br>` +
                    `= (${xdx.toFixed(2)} - ${xValue.toFixed(2)}) / (${f_g_plus_dg.toFixed(3)} - ${f_g.toFixed(3)}) <br>` +
                    `= ${dfdg.toFixed(3)} × ${dgdx.toFixed(3)}`;
            }
            
            draw() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                this.drawGrid();
                this.drawAxes();
                
                if (this.showFunc1Checkbox.checked) {
                    this.drawFunction(this.func1);
                }
                
                if (this.showFunc2Checkbox.checked) {
                    this.drawFunction(this.func2);
                }
                
                if (this.showCompositionCheckbox.checked) {
                    this.drawComposition();
                }
                
                if (this.showIdentityCheckbox.checked) {
                    this.drawIdentityLine();
                }
                
                // Рисуем пересечение с g(x)
                this.drawIntersection();
                
                // Обновляем производные
                this.updateDerivatives();
            }
            
            setupEventListeners() {
                // Драг (перетаскивание)
                this.canvas.addEventListener('mousedown', (e) => {
                    this.isDragging = true;
                    const rect = this.canvas.getBoundingClientRect();
                    this.lastMouseX = (e.clientX - rect.left) * (this.displayWidth / rect.width);
                    this.lastMouseY = (e.clientY - rect.top) * (this.displayHeight / rect.height);
                    this.canvas.style.cursor = 'grabbing';
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    this.isDragging = false;
                    this.canvas.style.cursor = 'grab';
                });
                
                this.canvas.addEventListener('mouseleave', () => {
                    this.isDragging = false;
                    this.canvas.style.cursor = 'grab';
                    this.coordsDisplay.textContent = 'Hover over the graph';
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const canvasX = (e.clientX - rect.left) * (this.displayWidth / rect.width);
                    const canvasY = (e.clientY - rect.top) * (this.displayHeight / rect.height);
                    
                    if (this.isDragging) {
                        const dx = canvasX - this.lastMouseX;
                        const dy = canvasY - this.lastMouseY;
                        this.offsetX += dx;
                        this.offsetY += dy;
                        this.lastMouseX = canvasX;
                        this.lastMouseY = canvasY;
                        this.saveViewState();
                        this.draw();
                    }
                    
                    const x = this.toMathX(canvasX);
                    const y = this.toMathY(canvasY);
                    const f = this.func1.calculateY(x);
                    const g = this.func2.calculateY(x);
                    const composition = this.calculateComposition(x);
                    
                    this.coordsDisplay.textContent = `x = ${x.toFixed(2)}, y = ${y.toFixed(2)}, f(x) = ${f.toFixed(2)}, g(x) = ${g.toFixed(2)}, f(g(x)) = ${composition.toFixed(2)}`;
                });
                
                // Зум (колесико мыши)
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    
                    const rect = this.canvas.getBoundingClientRect();
                    const canvasX = (e.clientX - rect.left) * (this.displayWidth / rect.width);
                    const canvasY = (e.clientY - rect.top) * (this.displayHeight / rect.height);
                    
                    // Позиция в математических координатах до зума
                    const xBefore = this.toMathX(canvasX);
                    const yBefore = this.toMathY(canvasY);
                    
                    // Изменяем масштаб
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    this.scale *= zoomFactor;
                    
                    // Ограничение масштаба
                    this.scale = Math.max(5, Math.min(200, this.scale));
                    
                    // Позиция в математических координатах после зума
                    const xAfter = this.toMathX(canvasX);
                    const yAfter = this.toMathY(canvasY);
                    
                    // Корректируем смещение, чтобы точка под курсором осталась на месте
                    this.offsetX += (xAfter - xBefore) * this.scale;
                    this.offsetY -= (yAfter - yBefore) * this.scale;
                    
                    this.saveViewState();
                    this.draw();
                });
                
                // Устанавливаем курсор
                this.canvas.style.cursor = 'grab';
                
                // Обработчики для checkbox'ов
                this.showFunc1Checkbox.addEventListener('change', () => {
                    this.saveVisibilityState();
                    this.draw();
                });
                this.showFunc2Checkbox.addEventListener('change', () => {
                    this.saveVisibilityState();
                    this.draw();
                });
                this.showCompositionCheckbox.addEventListener('change', () => {
                    this.saveVisibilityState();
                    this.draw();
                });
                this.showIdentityCheckbox.addEventListener('change', () => {
                    this.saveVisibilityState();
                    this.draw();
                });
                
                // Кнопки управления масштабом
                document.getElementById('zoomIn').addEventListener('click', () => {
                    this.scale *= 1.2;
                    this.scale = Math.min(200, this.scale);
                    this.saveViewState();
                    this.draw();
                });
                
                document.getElementById('zoomOut').addEventListener('click', () => {
                    this.scale *= 0.8;
                    this.scale = Math.max(5, this.scale);
                    this.saveViewState();
                    this.draw();
                });
                
                // Кнопка сброса вида
                document.getElementById('resetView').addEventListener('click', () => {
                    this.scale = 40;
                    this.offsetX = 0;
                    this.offsetY = 0;
                    this.saveViewState();
                    this.draw();
                });
                
                // Кнопки перемещения
                const moveStep = 50; // Шаг перемещения в пикселях
                
                document.getElementById('moveUp').addEventListener('click', () => {
                    this.offsetY += moveStep;
                    this.saveViewState();
                    this.draw();
                });
                
                document.getElementById('moveDown').addEventListener('click', () => {
                    this.offsetY -= moveStep;
                    this.saveViewState();
                    this.draw();
                });
                
                document.getElementById('moveLeft').addEventListener('click', () => {
                    this.offsetX -= moveStep;
                    this.saveViewState();
                    this.draw();
                });
                
                document.getElementById('moveRight').addEventListener('click', () => {
                    this.offsetX += moveStep;
                    this.saveViewState();
                    this.draw();
                });
                
                // Обработчик изменения поля пересечения
                document.getElementById('intersectionX').addEventListener('input', () => {
                    this.saveIntersectionX();
                    this.draw();
                });
                
                // Обработчики кнопок +/- для координаты пересечения
                document.getElementById('btnXMinus').addEventListener('click', () => {
                    const input = document.getElementById('intersectionX');
                    const currentValue = parseFloat(input.value) || 0;
                    input.value = (currentValue - 0.1).toFixed(1);
                    this.saveIntersectionX();
                    this.draw();
                });
                
                document.getElementById('btnXPlus').addEventListener('click', () => {
                    const input = document.getElementById('intersectionX');
                    const currentValue = parseFloat(input.value) || 0;
                    input.value = (currentValue + 0.1).toFixed(1);
                    this.saveIntersectionX();
                    this.draw();
                });
                
                // Обработчики кнопок +/- для dx
                document.getElementById('btnDxMinus').addEventListener('click', () => {
                    const input = document.getElementById('dxInput');
                    const currentValue = parseFloat(input.value) || 0;
                    const newValue = Math.max(0, currentValue - 0.1);
                    input.value = newValue.toFixed(1);
                    this.saveDx();
                    this.draw();
                });
                
                document.getElementById('btnDxPlus').addEventListener('click', () => {
                    const input = document.getElementById('dxInput');
                    const currentValue = parseFloat(input.value) || 0;
                    input.value = (currentValue + 0.1).toFixed(1);
                    this.saveDx();
                    this.draw();
                });
                
                // Обработчик изменения dx
                document.getElementById('dxInput').addEventListener('input', () => {
                    this.saveDx();
                    this.draw();
                });
                
                // Обработчик видимости вертикальной линии
                document.getElementById('showVerticalLine').addEventListener('change', () => {
                    this.saveVisibilityState();
                    this.draw();
                });
                
                // Обработчик видимости горизонтальной линии до y=x
                document.getElementById('showHorizontalToIdentity').addEventListener('change', () => {
                    this.saveVisibilityState();
                    this.draw();
                });
                
                // Обработчик видимости вертикальной линии до f(x)
                document.getElementById('showVerticalToF').addEventListener('change', () => {
                    this.saveVisibilityState();
                    this.draw();
                });
                
                // Обработчик видимости горизонтальной линии до f(g(x))
                document.getElementById('showHorizontalToComposition').addEventListener('change', () => {
                    this.saveVisibilityState();
                    this.draw();
                });
                
                // Обработчик видимости линий для x+dx
                document.getElementById('showDxLines').addEventListener('change', () => {
                    this.saveVisibilityState();
                    this.draw();
                });
                
                // Обработчик видимости координат точек
                document.getElementById('showCoordinates').addEventListener('change', () => {
                    this.saveVisibilityState();
                    this.draw();
                });
            }
        }
        
        // Создаём данные функций
        const func1 = new FunctionData({
            coeffAId: 'coeffA1',
            coeffBId: 'coeffB1',
            coeffCId: 'coeffC1',
            formulaId: 'formula1',
            legendFormulaId: 'legendFormula1',
            funcTypeName: 'funcType1',
            btnAMinusId: 'btnA1Minus',
            btnAPlusId: 'btnA1Plus',
            btnBMinusId: 'btnB1Minus',
            btnBPlusId: 'btnB1Plus',
            btnCMinusId: 'btnC1Minus',
            btnCPlusId: 'btnC1Plus',
            label: 'f(x)',
            color: '#0066cc',
            storageKey: 'func1-settings'
        });
        
        const func2 = new FunctionData({
            coeffAId: 'coeffA2',
            coeffBId: 'coeffB2',
            coeffCId: 'coeffC2',
            formulaId: 'formula2',
            legendFormulaId: 'legendFormula2',
            funcTypeName: 'funcType2',
            btnAMinusId: 'btnA2Minus',
            btnAPlusId: 'btnA2Plus',
            btnBMinusId: 'btnB2Minus',
            btnBPlusId: 'btnB2Plus',
            btnCMinusId: 'btnC2Minus',
            btnCPlusId: 'btnC2Plus',
            label: 'g(x)',
            color: '#cc0000',
            storageKey: 'func2-settings'
        });
        
        // Проверяем первый запуск и устанавливаем дефолтные значения
        const isFirstRun = !localStorage.getItem('func1-settings') && !localStorage.getItem('func2-settings');
        if (isFirstRun) {
            // f(x) = x^0.5
            func1.funcType = 'power';
            func1.a = 1;
            func1.b = 0.5;
            func1.c = 0;
            func1.coeffAInput.value = 1;
            func1.coeffBInput.value = 0.5;
            func1.coeffCInput.value = 0;
            document.querySelector('input[name="funcType1"][value="power"]').checked = true;
            func1.saveToStorage();
            func1.updateFormula();
            
            // g(x) = 0.5x^2 + 1
            func2.funcType = 'polynomial';
            func2.a = 0.5;
            func2.b = 0;
            func2.c = 1;
            func2.coeffAInput.value = 0.5;
            func2.coeffBInput.value = 0;
            func2.coeffCInput.value = 1;
            document.querySelector('input[name="funcType2"][value="polynomial"]').checked = true;
            func2.saveToStorage();
            func2.updateFormula();
            
            // x = 4
            document.getElementById('intersectionX').value = '4';
            localStorage.setItem('intersection-x', '4');
            
            // dx = 0.5
            document.getElementById('dxInput').value = '0.5';
            localStorage.setItem('dx-value', '0.5');
            
            // Показать линии для x+dx
            document.getElementById('showDxLines').checked = true;
            
            // Показать координаты точек
            document.getElementById('showCoordinates').checked = true;
            
            // Показать блок производных
            localStorage.setItem('derivatives-visible', 'true');
        }
        
        // Создаём объединённый график
        const graph = new CombinedGraph('mainCanvas', func1, func2);
        
        // Если это первый запуск, сохраняем состояние видимости
        if (isFirstRun) {
            graph.saveVisibilityState();
        }
        
        // Связываем обновления
        func1.onUpdate = () => graph.draw();
        func2.onUpdate = () => graph.draw();
        
        // Функция сброса на дефолтные значения
        function resetToDefaults() {
            // f(x) = x^0.5
            func1.funcType = 'power';
            func1.a = 1;
            func1.b = 0.5;
            func1.c = 0;
            func1.coeffAInput.value = 1;
            func1.coeffBInput.value = 0.5;
            func1.coeffCInput.value = 0;
            document.querySelector('input[name="funcType1"][value="power"]').checked = true;
            func1.saveToStorage();
            func1.updateFormula();
            
            // g(x) = 0.5x^2 + 1
            func2.funcType = 'polynomial';
            func2.a = 0.5;
            func2.b = 0;
            func2.c = 1;
            func2.coeffAInput.value = 0.5;
            func2.coeffBInput.value = 0;
            func2.coeffCInput.value = 1;
            document.querySelector('input[name="funcType2"][value="polynomial"]').checked = true;
            func2.saveToStorage();
            func2.updateFormula();
            
            // x = 4
            document.getElementById('intersectionX').value = '4';
            localStorage.setItem('intersection-x', '4');
            
            // dx = 0.5
            document.getElementById('dxInput').value = '0.5';
            localStorage.setItem('dx-value', '0.5');
            
            // Показать линии для x+dx
            document.getElementById('showDxLines').checked = true;
            
            // Показать координаты точек
            document.getElementById('showCoordinates').checked = true;
            
            // Показать блок производных
            derivativesContent.style.display = 'flex';
            toggleDerivativesBtn.textContent = 'Derivatives ▲';
            saveDerivativesVisibility(true);
            
            graph.saveVisibilityState();
            
            graph.draw();
        }
        
        // Обработчик кнопки сброса на дефолты
        document.getElementById('resetToDefaults').addEventListener('click', resetToDefaults);
        
        // Обработчик изменения размера окна
        window.addEventListener('resize', () => {
            graph.updateCanvasSize();
            graph.draw();
        });
        
        // Управление видимостью блока производных
        const derivativesContent = document.getElementById('derivativesContent');
        const toggleDerivativesBtn = document.getElementById('toggleDerivatives');
        
        // Загрузка состояния блока производных из localStorage
        function loadDerivativesVisibility() {
            try {
                const saved = localStorage.getItem('derivatives-visible');
                if (saved === 'true') {
                    derivativesContent.style.display = 'flex';
                    toggleDerivativesBtn.textContent = 'Derivatives ▲';
                } else {
                    derivativesContent.style.display = 'none';
                    toggleDerivativesBtn.textContent = 'Derivatives ▼';
                }
            } catch (e) {
                console.error('Error loading derivatives visibility:', e);
            }
        }
        
        // Сохранение состояния блока производных в localStorage
        function saveDerivativesVisibility(visible) {
            try {
                localStorage.setItem('derivatives-visible', visible);
            } catch (e) {
                console.error('Error saving derivatives visibility:', e);
            }
        }
        
        loadDerivativesVisibility();
        
        toggleDerivativesBtn.addEventListener('click', () => {
            const isVisible = derivativesContent.style.display === 'flex';
            derivativesContent.style.display = isVisible ? 'none' : 'flex';
            toggleDerivativesBtn.textContent = isVisible ? 'Derivatives ▼' : 'Derivatives ▲';
            saveDerivativesVisibility(!isVisible);
        });
        
        // Управление видимостью контролов
        const controlsContainer = document.querySelector('.controls-container');
        const toggleControlsBtn = document.getElementById('toggleControls');
        
        // Загрузка состояния контролов из localStorage
        function loadControlsVisibility() {
            try {
                const saved = localStorage.getItem('controls-visible');
                if (saved === 'true') {
                    controlsContainer.classList.remove('hidden');
                    toggleControlsBtn.textContent = 'Settings ▲';
                }
            } catch (e) {
                console.error('Error loading controls visibility:', e);
            }
        }
        
        // Сохранение состояния контролов в localStorage
        function saveControlsVisibility(visible) {
            try {
                localStorage.setItem('controls-visible', visible);
            } catch (e) {
                console.error('Error saving controls visibility:', e);
            }
        }
        
        loadControlsVisibility();
        
        toggleControlsBtn.addEventListener('click', () => {
            const isHidden = controlsContainer.classList.toggle('hidden');
            if (isHidden) {
                toggleControlsBtn.textContent = 'Settings ▼';
                saveControlsVisibility(false);
            } else {
                toggleControlsBtn.textContent = 'Settings ▲';
                saveControlsVisibility(true);
            }
        });
    </script>
</body>
</html>
